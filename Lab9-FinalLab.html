<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Fractal Geometry Computational Lucca's Extra Lab Report on Hilbert Curve" />
  <link rel="stylesheet" href="https://latex.vercel.app/style.css" />
  <link 
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"
  />
  <script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    // This configures MathJax to recognize $...$ and $$...$$ as math delimiters.
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
      }
    }
  </script>
  <title>Fractal Geometry Final Lab Report</title> 
</head>
<body id="top">

  <header>
    <h1>Final Lab Report - Chaos Game, L-Systems and Hilbert Curves</h1>
    <p class="author">
      Lucca Tanzillo dos Santos <br />
      April 30rd, 2025
    </p>
  </header>

  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
<p>
  [INTRO HERE]
</p>
      </section>

      <!-- PART I -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="Chaos Game">
        <h2>1. Chaos Game</h2>
        <p>
          In this section, I start by documenting the original Chaos Game code I first ran in Google Colab. 
  The code generates the Sierpinski Triangle by repeatedly moving a point halfway toward one of three triangle vertices chosen at random. 
  After explaining the static version, I expand the code to create an animation that shows the fractal forming point by point, making the process more visual and intuitive.

        </p>


        <h3>1.1 Original Code Documented</h3>
        <p>
       This Python code generates the Sierpinski Triangle using the Chaos Game method. 
          It starts with an equilateral triangle defined by three vertices and a random initial point. 
          At each step, it randomly selects one of the triangle’s corners and moves halfway from the current point 
          to that vertex, repeating this process 50,000 times. The resulting points are plotted using matplotlib, 
          and over time they reveal the fractal structure of the Sierpinski Triangle.
        </p>
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<pre><code class="language-python">
# Importing the requirements we need
import matplotlib.pyplot as plt  # For drawing
from random import random, randint  # To get random numbers
import numpy as np  # For math (mainly square root here)

# This function just finds the point halfway between two others
def midpoint(P, Q):
    return (0.5 * (P[0] + Q[0]), 0.5 * (P[1] + Q[1]))

# Here we define the 3 corners of an equilateral triangle
# One at the bottom left, one at the bottom right, and one at the top center
vertices = [(0, 0), (2, 2 * np.sqrt(3)), (4, 0)]

# We'll generate 50,000 points to form the triangle
iterates = 50000

# These lists will hold the x and y coordinates of all the points
x, y = [0] * iterates, [0] * iterates

# Start with a random point somewhere on the canvas
x[0], y[0] = random(), random()

# Now we play the “chaos game”:
# At each step, pick one of the triangle’s corners at random
# and move halfway from the current point to that corner
for i in range(1, iterates):
    k = randint(0, 2)  # Pick a random corner (0, 1, or 2)
    x[i], y[i] = midpoint(vertices[k], (x[i - 1], y[i - 1]))

# Set up the plot
plt.figure(figsize=(8, 8))  # Square plot

# Plot all the points really small to get that fractal look
plt.scatter(x, y, color='b', s=0.1)

# Add a title so we know what we’re looking at
plt.title('Sierpinski Triangle Generated Using the Chaos Game')

# Make sure the triangle doesn’t get squished
plt.axis('equal')

# Show the final result!
plt.show()
</code></pre>
        
<p>
The figure below shows the output of a Python program that generates the Sierpinski Triangle using 
  the Chaos Game algorithm. By repeatedly selecting random triangle vertices and plotting midpoints, 
  the code reveals the self-similar fractal structure from a seemingly random process.
</p>

  <!-- EXAMPLE FIGURE FOR BROAD VIEW -->
  <!-- -------------------------------------------------------------------------------------------- -->
        <figure>
          <img
            src="https://luccatsantos.github.io/labreports/images/sierpinskitriangle.png"
            alt="Chaos Game Static"
            width="600"
            height="600"
            loading="lazy"
          />
          <figcaption>
            <strong>Sierpinski Triangle:</strong> Built from 50,000 random midpoints.
          </figcaption>
        </figure>
      </section>

        <h3>1.2 Expanding the code</h3>
        <p>
    In the next code, I extend the basic Chaos Game implementation by turning it into an animated visualization of how the Sierpinski Triangle forms over time. 
    Instead of plotting all the points at once like in the static version, I use <code>matplotlib.animation</code> to update the plot frame by frame. 
    I start with a random point inside the canvas and, at each step, move it halfway toward one of the triangle’s three vertices chosen at random. 
    By saving the animation as a GIF, I make the fractal-building process visible and intuitive. 
    This lets me show how order gradually emerges from randomness, making it easier to grasp the recursive structure behind the Sierpinski Triangle. 
        </p>
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<pre><code class="language-python">
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from random import random, randint
import numpy as np

# Set up the 3 corners of our triangle
vertices = [(0, 0), (2, 2 * np.sqrt(3)), (4, 0)]

# How many points (aka frames) we want in the animation
total_points = 2000

# Start with one random point somewhere on the screen
current_point = [random(), random()]

# Set up the canvas for drawing
fig, ax = plt.subplots(figsize=(4, 4), dpi=72)  # Smaller and lighter = faster to render
scat = ax.scatter([], [], color='b', s=0.5)  # Set up an empty scatter plot
ax.set_title("Animated Sierpinski Triangle")
ax.set_xlim(0, 4)
ax.set_ylim(0, 4)
ax.set_aspect('equal')  # Keeps triangle from looking squished

# We'll collect all the points here to show as the triangle builds
points = []

# This function runs once per frame to add a new point
def update(frame):
    global current_point
    # Pick one of the triangle corners at random
    chosen = vertices[randint(0, 2)]
    # Move halfway toward that corner
    current_point = [
        0.5 * (current_point[0] + chosen[0]),
        0.5 * (current_point[1] + chosen[1])
    ]
    # Save the new point and update the scatter plot
    points.append(current_point[:])
    scat.set_offsets(points)
    return scat,

# Put the animation together: run update() every frame
ani = animation.FuncAnimation(
    fig, update, frames=total_points, interval=1, blit=True, repeat=False
)

# Save it as a GIF so we can use it on websites, GitHub, etc.
ani.save("sierpinski2.gif", writer='pillow', fps=30)
</code></pre>
        
<p>
  The GIF below shows the Sierpinski Triangle forming point by point through the Chaos Game, 
  where each new point moves halfway toward a randomly chosen vertex of an equilateral triangle. 
  This process reveals the fractal’s structure over time.

</p>

  <!-- EXAMPLE FIGURE FOR BROAD VIEW -->
  <!-- -------------------------------------------------------------------------------------------- -->
<figure>
  <img 
    src="https://luccatsantos.github.io/labreports/images/sierpinski2.gif"
    alt="Chaos Game Animation"
    width="600"
    height="600"
    loading="lazy"
  />
  <figcaption>
    <strong>Chaos in Motion:</strong>2,000 points forming a fractal.
  </figcaption>
</figure>

      <!-- PART II -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="L-Systems">
        <h2>2. L-Systems</h2>
        <p>
        The code below deploys an interactive visualization to the Wolfram Cloud, where a grid of complex numbers is iteratively
          transformed and plotted based on a user-defined iteration count. The result is a dynamic display of evolving patterns in 
          the complex plane. It uses several key functions: <code>CloudDeploy</code> publishes the content online, <code>Manipulate</code> 
          enables real-time user interaction, and <code>Module</code> contains local variables to structure the computation.
          <code>Subdivide</code> generates evenly spaced values to define the grid, <code>Outer[Complex, x, y]</code> builds complex 
          coordinates, and <code>Flatten</code> reshapes the grid into a list. A <code>Do</code> loop applies the transformation
          iteratively, and <code>ListPlot</code> renders the results, with labels and styling handled by <code>Row</code> and 
          various plot options.
        </p>

        <h3>2.1 Original Code Documented</h3>
        <p>
        The code below deploys an interactive visualization to the Wolfram Cloud, where a grid of complex numbers is iteratively
          transformed and plotted based on a user-defined iteration count. The result is a dynamic display of evolving patterns in 
          the complex plane. It uses several key functions: <code>CloudDeploy</code> publishes the content online, <code>Manipulate</code> 
          enables real-time user interaction, and <code>Module</code> contains local variables to structure the computation.
          <code>Subdivide</code> generates evenly spaced values to define the grid, <code>Outer[Complex, x, y]</code> builds complex 
          coordinates, and <code>Flatten</code> reshapes the grid into a list. A <code>Do</code> loop applies the transformation
          iteratively, and <code>ListPlot</code> renders the results, with labels and styling handled by <code>Row</code> and 
          various plot options.
        </p>
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<pre><code class="language-python">
def hilbert_curve(step, parity, n):
    "Draw a Hilbert curve of order n with given turtle, step size, and parity."
    if n == 0:
        return  # base case: no more recursion
    left(90 * parity)
    hilbert_curve(step, -parity, n - 1)      # Draw smaller curve with flipped parity
    forward(step)
    right(90 * parity)
    hilbert_curve(step, parity, n - 1)       # Draw smaller curve with same parity
    forward(step)
    hilbert_curve(step, parity, n - 1)       # Draw another with same parity
    right(90 * parity)     
    forward(step)
    hilbert_curve(step, -parity, n - 1)      # Draw smaller curve with flipped parity
    left(90 * parity)
    
# Set up the variables
n = 3
step = 500 / (2 ** n)  # scale step so curve stays within bounds

initializeTurtle()
showturtle()

# Set up the turtle
face(90)
jump(200, 550)
color('red')

# Draw the Hilbert Curve

hilbert_curve(step, 1, n)

show()
</code></pre>
        
<p>
    The plot below shows the result of interactively transforming a complex grid after one iteration, with the number of iterations 
    controlled dynamically using the <code>Manipulate</code> interface. This built-in Wolfram Mathematica feature allows users to 
    adjust parameters in real time and immediately observe the effects on the visual structure of the grid. The interface makes 
    mexploration of complex behaviors both intuitive and efficient, enabling deeper insight into how iterative transformations distort 
    mand evolve spatial patterns. Wolfram Mathematica is ideal for this task due to its native support for complex arithmetic, 
    mefficient array operations, and built-in interactivity through <code>Manipulate</code>, making it easy to explore and share 
    mathematical behavior visually and intuitively.
</p>

  <!-- EXAMPLE FIGURE FOR BROAD VIEW -->
  <!-- -------------------------------------------------------------------------------------------- -->
        <figure>
          <img
            alt="Hilbert Curves from n = 1 tp n = 6"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong>Hilbert Curves:</strong> Variations from n = 1 to n = 6.
          </figcaption>
        </figure>
      </section>

        <h3>2.2 Expanding the code</h3>
        <p>
        The code below deploys an interactive visualization to the Wolfram Cloud, where a grid of complex numbers is iteratively
          transformed and plotted based on a user-defined iteration count. The result is a dynamic display of evolving patterns in 
          the complex plane. It uses several key functions: <code>CloudDeploy</code> publishes the content online, <code>Manipulate</code> 
          enables real-time user interaction, and <code>Module</code> contains local variables to structure the computation.
          <code>Subdivide</code> generates evenly spaced values to define the grid, <code>Outer[Complex, x, y]</code> builds complex 
          coordinates, and <code>Flatten</code> reshapes the grid into a list. A <code>Do</code> loop applies the transformation
          iteratively, and <code>ListPlot</code> renders the results, with labels and styling handled by <code>Row</code> and 
          various plot options.
        </p>
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<pre><code class="language-python">
def hilbert_curve(step, parity, n):
    "Draw a Hilbert curve of order n with given turtle, step size, and parity."
    if n == 0:
        return  # base case: no more recursion
    left(90 * parity)
    hilbert_curve(step, -parity, n - 1)      # Draw smaller curve with flipped parity
    forward(step)
    right(90 * parity)
    hilbert_curve(step, parity, n - 1)       # Draw smaller curve with same parity
    forward(step)
    hilbert_curve(step, parity, n - 1)       # Draw another with same parity
    right(90 * parity)     
    forward(step)
    hilbert_curve(step, -parity, n - 1)      # Draw smaller curve with flipped parity
    left(90 * parity)
    
# Set up the variables
n = 3
step = 500 / (2 ** n)  # scale step so curve stays within bounds

initializeTurtle()
showturtle()

# Set up the turtle
face(90)
jump(200, 550)
color('red')

# Draw the Hilbert Curve

hilbert_curve(step, 1, n)

show()
</code></pre>
        
<p>
    The plot below shows the result of interactively transforming a complex grid after one iteration, with the number of iterations 
    controlled dynamically using the <code>Manipulate</code> interface. This built-in Wolfram Mathematica feature allows users to 
    adjust parameters in real time and immediately observe the effects on the visual structure of the grid. The interface makes 
    mexploration of complex behaviors both intuitive and efficient, enabling deeper insight into how iterative transformations distort 
    mand evolve spatial patterns. Wolfram Mathematica is ideal for this task due to its native support for complex arithmetic, 
    mefficient array operations, and built-in interactivity through <code>Manipulate</code>, making it easy to explore and share 
    mathematical behavior visually and intuitively.
</p>

  <!-- EXAMPLE FIGURE FOR BROAD VIEW -->
  <!-- -------------------------------------------------------------------------------------------- -->
        <figure>
          <img
            alt="Hilbert Curves from n = 1 tp n = 6"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong>Hilbert Curves:</strong> Variations from n = 1 to n = 6.
          </figcaption>
        </figure>
      </section>

      <!-- PART III -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="Hilbert Curves">
        <h2>3. Hilbert Curves</h2>
        <p>
        This section explores the construction and visualization of Hilbert Curves, a type of space-filling fractal that maps a continuous line through every point in a 2D grid without crossing itself. 
  First described by David Hilbert in 1891, the curve demonstrates how recursive geometric rules can translate into efficient space coverage, making it useful in fields like computer graphics and data indexing (Sagan, 1994). 
  The section begins by documenting an L-system approach to generate the curve and then simplifies the method using direct recursion.
        </p>

        <h3>3.1 Original Code Documented</h3>
        <p>
        The following section documents the implementation of the Hilbert Curve using an L-system approach.
          This method separates the process into two parts: first, it generates a sequence of drawing
          commands by applying recursive rewriting rules to an initial axiom; then, it interprets that
          sequence to produce the final curve using turtle graphics. This structure provides a flexible
          way to model fractals and highlights how simple symbolic rules can create complex geometric
          patterns.

        </p>
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<pre><code class="language-python">
# Importing the math module (though it's not used in this version)
import math

# Set up the turtle environment and make the turtle visible
initializeTurtle()
showturtle()

# Applies a rule to a single character; if no rule exists, returns the character unchanged
def apply_rules(char, rules):
    return rules.get(char, char)

# Builds the full L-system string by applying the rules repeatedly over a number of iterations
def generate_lsystem(axiom, rules, iterations):
    current_string = axiom
    for _ in range(iterations):
        next_string = ''.join([apply_rules(char, rules) for char in current_string])
        current_string = next_string
    return current_string

# Interprets the L-system string and uses turtle graphics to draw it
# 'F' means move forward, '+' and '-' are turns, all other characters are ignored
def draw_lsystem(turtle_string, length, angle):
    for command in turtle_string:
        if command == 'F':
            forward(length)
        elif command == '+':
            left(angle)
        elif command == '-':
            right(angle)
        else:
            pass  # Ignore characters that don't correspond to drawing instructions

# Define the axiom and production rules for the Hilbert Curve
axiom = 'L'
rules = {
    'L': '-RF+LFL+FR-',
    'R': '+LF-RFR-FL+'
}
iterations = 6  # Determines the order of the Hilbert curve
angle = 90      # Turning angle used in the pattern

# Generate the full string of drawing instructions using the rules
hilbert_string = generate_lsystem(axiom, rules, iterations)

# Calculate the step length based on the canvas size and number of segments
size = 400
n = 2 ** iterations - 1
length = size / n

# Move the turtle to a starting position and set drawing settings
jump(400, 500)
face(0)
color('blue')

# Draw the Hilbert Curve using the L-system string
draw_lsystem(hilbert_string, length, angle)

# Display the result on the canvas
show()
</code></pre>
        
<p>
    This output shows the Hilbert Curve of order 6 generated using an L-system.
  The pattern fills the space with 9,558 connected points, forming a highly structured fractal grid.

</p>

  <!-- EXAMPLE FIGURE FOR BROAD VIEW -->
  <!-- -------------------------------------------------------------------------------------------- -->
        <figure>
          <img
            src="images/hilbertcurvesLsystem.png"
            alt="Hilbert Curves from n = 1 tp n = 6"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong>Hilbert Curves:</strong> Variations from n = 1 to n = 6.
          </figcaption>
        </figure>
      </section>

        <h3>3.2 Expanding the code</h3>
        <p>
        In this lab, instead of expanding the previous L-system implementation, I chose to simplify the approach by using a direct recursive function to draw the Hilbert Curve. 
  The function <code>hilbert_curve(step, parity, n)</code> captures the recursive nature of the curve without relying on symbolic string rewriting. 
  It draws the pattern by calling itself with smaller orders, adjusting direction based on the parity, and moving forward at each step. 
  This version is more concise and easier to follow, making the recursive structure of the Hilbert Curve more transparent while producing the same visual result.

        </p>
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<pre><code class="language-python">
def hilbert_curve(step, parity, n):
    "Draw a Hilbert curve of order n with given turtle, step size, and parity."
    if n == 0:
        return  # base case: no more recursion
    left(90 * parity)
    hilbert_curve(step, -parity, n - 1)      # Draw smaller curve with flipped parity
    forward(step)
    right(90 * parity)
    hilbert_curve(step, parity, n - 1)       # Draw smaller curve with same parity
    forward(step)
    hilbert_curve(step, parity, n - 1)       # Draw another with same parity
    right(90 * parity)     
    forward(step)
    hilbert_curve(step, -parity, n - 1)      # Draw smaller curve with flipped parity
    left(90 * parity)
    
# Set up the variables
n = 3
step = 500 / (2 ** n)  # scale step so curve stays within bounds

initializeTurtle()
showturtle()

# Set up the turtle
face(90)
jump(200, 550)
color('red')

# Draw the Hilbert Curve

hilbert_curve(step, 1, n)

show()
</code></pre>
        
<p>
    This figure below shows the recursive construction of the Hilbert Curve from order 1 to order 6 using 
  turtle graphics. Each image demonstrates how the curve becomes increasingly complex with each recursive 
  step, starting from a simple U-shaped pattern and evolving into a dense, space-filling structure.
  The turtle’s position and path progression are visible at each stage, highlighting the consistent use
  of right-angle turns and uniform step sizes to trace the curve.
</p>

  <!-- EXAMPLE FIGURE FOR BROAD VIEW -->
  <!-- -------------------------------------------------------------------------------------------- -->
        <figure>
          <img
            src="https://luccatsantos.github.io/labreports/images/hilbertcurves.png"
            alt="Hilbert Curves from n = 1 tp n = 6"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            <strong>Hilbert Curves:</strong> Variations from n = 1 to n = 6.
          </figcaption>
        </figure>
      </section>       

      <!-- REFERENCES SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="references">
        <h2>References</h2>
        <p>
          The following reference was consulted during the preparation of this lab:
        </p>
        <ol>
          <li>
            Sagan, H. (1994). <em>Space-filling curves</em>. Springer-Verlag.
          </li>
        </ol>
      </section>
    </article>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
